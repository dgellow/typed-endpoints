/**
 * HTTP Executor Tests
 *
 * Tests protocol composition from endpoints using fromEndpoint/fromEndpointDependent.
 */

import { assertEquals, assertRejects } from "@std/assert";
import { z } from "zod";

import { createApiHandlers, endpoint } from "../integrations/fresh.ts";
import { createHttpExecutor, HttpError } from "./http.ts";
import { createSession } from "./client.ts";
import { protocol } from "./dsl.ts";
import { fromEndpoint, fromEndpointDependent } from "./compose.ts";

// =============================================================================
// Test Endpoint Handlers (simulating route files)
// =============================================================================

// routes/api/auth/login.ts
const loginHandler = createApiHandlers({
  POST: endpoint({
    operationId: "authLogin",
    body: z.object({ username: z.string(), password: z.string() }),
    response: z.object({
      sessionId: z.string(),
      accessToken: z.string(),
    }),
    handler: () => Response.json({ sessionId: "s", accessToken: "t" }),
  }),
});

// routes/api/users/profile.ts
const profileHandler = createApiHandlers({
  GET: endpoint({
    operationId: "usersProfile",
    response: z.object({ name: z.string(), email: z.string() }),
    handler: () => Response.json({ name: "Test", email: "test@example.com" }),
  }),
});

// routes/api/auth/logout.ts (no operationId - tests fallback to step name)
const logoutHandler = createApiHandlers({
  POST: endpoint({
    response: z.object({ success: z.boolean() }),
    handler: () => Response.json({ success: true }),
  }),
});

// routes/api/users/[userId].ts
const userHandler = createApiHandlers({
  GET: endpoint({
    operationId: "usersRetrieve",
    params: z.object({ userId: z.string() }),
    response: z.object({ id: z.string(), name: z.string() }),
    handler: () => Response.json({ id: "1", name: "User" }),
  }),
});

// =============================================================================
// Test Protocol (composed from endpoints)
// =============================================================================

const authProtocol = protocol({
  name: "AuthProtocol",
  initial: "login",
  terminal: ["logout"],
  steps: {
    login: fromEndpoint(loginHandler, "POST", { name: "login" }),
    getProfile: fromEndpointDependent(profileHandler, "GET", {
      name: "getProfile",
      dependsOn: "login",
      request: () => z.object({}),
    }),
    logout: fromEndpointDependent(logoutHandler, "POST", {
      name: "logout",
      dependsOn: "login",
      request: () => z.object({}),
    }),
  },
});

// Protocol with path parameters (composed from endpoint)
const usersProtocol = protocol({
  name: "UsersProtocol",
  initial: "getUser",
  steps: {
    getUser: fromEndpoint(userHandler, "GET", { name: "getUser" }),
  },
});

// Test routes (would be generated by tsgen --format routes)
const testRoutes = {
  authLogin: { method: "POST", path: "/api/auth/login" },
  usersProfile: { method: "GET", path: "/api/users/profile" },
  logout: { method: "POST", path: "/api/auth/logout" },
  usersRetrieve: { method: "GET", path: "/api/users/{userId}" },
} as const;

// =============================================================================
// Helper Types
// =============================================================================

// Type for RequestInit that works with Deno's union type
interface MockRequestInit {
  method?: string;
  headers?: Record<string, string>;
  body?: string;
}

// =============================================================================
// Basic Request Tests
// =============================================================================

Deno.test("createHttpExecutor makes HTTP request with correct method and path", async () => {
  const requestLog: { url: string; method: string; body: unknown }[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;
    const opts = init as MockRequestInit | undefined;
    requestLog.push({
      url,
      method: opts?.method ?? "GET",
      body: opts?.body ? JSON.parse(opts.body) : undefined,
    });

    return Promise.resolve(
      new Response(
        JSON.stringify({ sessionId: "sess-123", accessToken: "token-abc" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);
  await session.execute("login", { username: "alice", password: "secret" });

  assertEquals(requestLog.length, 1);
  assertEquals(requestLog[0].url, "https://api.example.com/api/auth/login");
  assertEquals(requestLog[0].method, "POST");
  assertEquals(requestLog[0].body, { username: "alice", password: "secret" });
});

Deno.test("createHttpExecutor uses operationId to find route", async () => {
  const requestLog: string[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;
    const opts = init as MockRequestInit | undefined;
    requestLog.push(`${opts?.method ?? "GET"} ${url}`);

    // Return appropriate response based on endpoint
    if (url.includes("login")) {
      return Promise.resolve(
        new Response(
          JSON.stringify({ sessionId: "s", accessToken: "t" }),
          { status: 200, headers: { "Content-Type": "application/json" } },
        ),
      );
    }

    // getProfile response
    return Promise.resolve(
      new Response(
        JSON.stringify({ name: "Alice", email: "alice@example.com" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.test.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);
  const { session: s1 } = await session.execute("login", {
    username: "bob",
    password: "pass",
  });

  // getProfile has operationId: "usersProfile"
  await s1.execute("getProfile", {});

  assertEquals(requestLog.length, 2);
  assertEquals(requestLog[0], "POST https://api.test.com/api/auth/login");
  assertEquals(requestLog[1], "GET https://api.test.com/api/users/profile");
});

Deno.test("createHttpExecutor falls back to step name when no operationId", async () => {
  const requestLog: string[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;
    const opts = init as MockRequestInit | undefined;
    requestLog.push(`${opts?.method ?? "GET"} ${url}`);

    if (url.includes("logout")) {
      return Promise.resolve(
        new Response(
          JSON.stringify({ success: true }),
          { status: 200, headers: { "Content-Type": "application/json" } },
        ),
      );
    }

    return Promise.resolve(
      new Response(
        JSON.stringify({ sessionId: "s", accessToken: "t" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.test.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);
  const { session: s1 } = await session.execute("login", {
    username: "u",
    password: "p",
  });

  // logout has no operationId, should use "logout" (step name)
  await s1.execute("logout", {});

  assertEquals(requestLog[1], "POST https://api.test.com/api/auth/logout");
});

// =============================================================================
// Path Parameter Tests
// =============================================================================

Deno.test("createHttpExecutor resolves path parameters from request", async () => {
  const requestLog: string[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;
    const opts = init as MockRequestInit | undefined;
    requestLog.push(`${opts?.method ?? "GET"} ${url}`);

    return Promise.resolve(
      new Response(
        JSON.stringify({ id: "user-123", name: "Alice" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(usersProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(usersProtocol, executor);
  await session.execute("getUser", { userId: "user-123" });

  assertEquals(requestLog[0], "GET https://api.example.com/api/users/user-123");
});

Deno.test("createHttpExecutor encodes path parameters", async () => {
  const requestLog: string[] = [];

  const mockFetch: typeof fetch = (input, _init) => {
    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;
    requestLog.push(url);

    return Promise.resolve(
      new Response(
        JSON.stringify({ id: "special", name: "Test" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(usersProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(usersProtocol, executor);
  await session.execute("getUser", { userId: "user/with spaces" });

  assertEquals(
    requestLog[0],
    "https://api.example.com/api/users/user%2Fwith%20spaces",
  );
});

// =============================================================================
// Auth Token Propagation Tests
// =============================================================================

Deno.test("createHttpExecutor auto-injects auth token from previous step", async () => {
  const headerLog: Record<string, string | null>[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const opts = init as MockRequestInit | undefined;
    headerLog.push({
      authorization: opts?.headers?.["Authorization"] ?? null,
    });

    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;

    if (url.includes("login")) {
      return Promise.resolve(
        new Response(
          JSON.stringify({ sessionId: "s", accessToken: "my-secret-token" }),
          { status: 200, headers: { "Content-Type": "application/json" } },
        ),
      );
    }

    return Promise.resolve(
      new Response(
        JSON.stringify({ name: "Alice", email: "alice@example.com" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
    auth: {
      fromStep: "login",
      tokenPath: "accessToken",
    },
  });

  const session = createSession(authProtocol, executor);
  const { session: s1 } = await session.execute("login", {
    username: "alice",
    password: "pass",
  });

  // First request (login) shouldn't have auth
  assertEquals(headerLog[0].authorization, null);

  await s1.execute("getProfile", {});

  // Second request should have auth token from login response
  assertEquals(headerLog[1].authorization, "Bearer my-secret-token");
});

Deno.test("createHttpExecutor supports custom auth header name and prefix", async () => {
  const headerLog: Record<string, string | null>[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const opts = init as MockRequestInit | undefined;
    headerLog.push({
      "x-api-key": opts?.headers?.["X-API-Key"] ?? null,
    });

    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;

    if (url.includes("login")) {
      return Promise.resolve(
        new Response(
          JSON.stringify({ sessionId: "s", accessToken: "api-key-12345" }),
          { status: 200, headers: { "Content-Type": "application/json" } },
        ),
      );
    }

    return Promise.resolve(
      new Response(
        JSON.stringify({ name: "Bob", email: "bob@example.com" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
    auth: {
      fromStep: "login",
      tokenPath: "accessToken",
      headerName: "X-API-Key",
      headerPrefix: "", // No prefix
    },
  });

  const session = createSession(authProtocol, executor);
  const { session: s1 } = await session.execute("login", {
    username: "bob",
    password: "pass",
  });

  await s1.execute("getProfile", {});

  assertEquals(headerLog[1]["x-api-key"], "api-key-12345");
});

Deno.test("createHttpExecutor supports nested token path", async () => {
  // Endpoint handlers with nested token response
  const nestedLoginHandler = createApiHandlers({
    POST: endpoint({
      operationId: "authLogin",
      body: z.object({ username: z.string(), password: z.string() }),
      response: z.object({
        data: z.object({
          auth: z.object({
            token: z.string(),
          }),
        }),
      }),
      handler: () => Response.json({ data: { auth: { token: "t" } } }),
    }),
  });

  const nestedProfileHandler = createApiHandlers({
    GET: endpoint({
      operationId: "usersProfile",
      response: z.object({ name: z.string() }),
      handler: () => Response.json({ name: "Test" }),
    }),
  });

  // Protocol composed from endpoints
  const nestedAuthProtocol = protocol({
    name: "NestedAuth",
    initial: "login",
    steps: {
      login: fromEndpoint(nestedLoginHandler, "POST", { name: "login" }),
      getProfile: fromEndpointDependent(nestedProfileHandler, "GET", {
        name: "getProfile",
        dependsOn: "login",
        request: () => z.object({}),
      }),
    },
  });

  const headerLog: string[] = [];

  const mockFetch: typeof fetch = (input, init) => {
    const opts = init as MockRequestInit | undefined;
    const authHeader = opts?.headers?.["Authorization"];
    if (authHeader) headerLog.push(authHeader);

    const url = typeof input === "string"
      ? input
      : input instanceof URL
      ? input.href
      : input.url;

    if (url.includes("login")) {
      return Promise.resolve(
        new Response(
          JSON.stringify({ data: { auth: { token: "nested-token" } } }),
          { status: 200, headers: { "Content-Type": "application/json" } },
        ),
      );
    }

    return Promise.resolve(
      new Response(
        JSON.stringify({ name: "Charlie" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(nestedAuthProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
    auth: {
      fromStep: "login",
      tokenPath: "data.auth.token",
    },
  });

  const session = createSession(nestedAuthProtocol, executor);
  const { session: s1 } = await session.execute("login", {
    username: "charlie",
    password: "pass",
  });

  await s1.execute("getProfile", {});

  assertEquals(headerLog[0], "Bearer nested-token");
});

// =============================================================================
// Error Handling Tests
// =============================================================================

Deno.test("createHttpExecutor throws HttpError on non-2xx response", async () => {
  const mockFetch: typeof fetch = () => {
    return Promise.resolve(
      new Response(
        JSON.stringify({
          error: "Unauthorized",
          message: "Invalid credentials",
        }),
        { status: 401, statusText: "Unauthorized" },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);

  await assertRejects(
    async () => {
      await session.execute("login", { username: "bad", password: "wrong" });
    },
    HttpError,
    "HTTP 401",
  );
});

Deno.test("HttpError contains status and body", async () => {
  const mockFetch: typeof fetch = () => {
    return Promise.resolve(
      new Response(
        JSON.stringify({ code: "RATE_LIMITED", retryAfter: 60 }),
        { status: 429, statusText: "Too Many Requests" },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);

  try {
    await session.execute("login", { username: "x", password: "y" });
    throw new Error("Should have thrown");
  } catch (e) {
    if (e instanceof HttpError) {
      assertEquals(e.status, 429);
      assertEquals(e.statusText, "Too Many Requests");
      assertEquals(e.body, '{"code":"RATE_LIMITED","retryAfter":60}');
    } else {
      throw e;
    }
  }
});

Deno.test("createHttpExecutor throws when route not found", async () => {
  const mockFetch: typeof fetch = () => {
    return Promise.resolve(new Response("{}", { status: 200 }));
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: {
      // Missing the authLogin route
      usersProfile: { method: "GET", path: "/api/users/profile" },
    },
    fetch: mockFetch,
  });

  const session = createSession(authProtocol, executor);

  await assertRejects(
    async () => {
      await session.execute("login", { username: "x", password: "y" });
    },
    Error,
    'No route found for step "login"',
  );
});

// =============================================================================
// Default Headers Tests
// =============================================================================

Deno.test("createHttpExecutor includes default headers", async () => {
  const headerLog: Record<string, string>[] = [];

  const mockFetch: typeof fetch = (_input, init) => {
    const opts = init as MockRequestInit | undefined;
    headerLog.push(opts?.headers ?? {});

    return Promise.resolve(
      new Response(
        JSON.stringify({ sessionId: "s", accessToken: "t" }),
        { status: 200, headers: { "Content-Type": "application/json" } },
      ),
    );
  };

  const executor = createHttpExecutor(authProtocol, {
    baseUrl: "https://api.example.com",
    routes: testRoutes,
    fetch: mockFetch,
    headers: {
      "X-Client-Version": "1.0.0",
      "X-Request-ID": "req-123",
    },
  });

  const session = createSession(authProtocol, executor);
  await session.execute("login", { username: "x", password: "y" });

  assertEquals(headerLog[0]["X-Client-Version"], "1.0.0");
  assertEquals(headerLog[0]["X-Request-ID"], "req-123");
  assertEquals(headerLog[0]["Content-Type"], "application/json");
});
