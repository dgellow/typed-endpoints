/**
 * HTTP Executor for Protocol System
 *
 * Bridges protocol sessions with actual HTTP transport by using
 * generated route metadata to map operationIds to HTTP endpoints.
 */

import type { AnyStep, Protocol } from "./types.ts";
import type { ExecutionContext, StepExecutor } from "./client.ts";

// =============================================================================
// Types
// =============================================================================

/** Route configuration - matches output from tsgen --format routes */
export interface RouteConfig {
  readonly method: string;
  readonly path: string;
}

/** Configuration for the HTTP executor */
export interface HttpExecutorConfig<
  TRoutes extends Record<string, RouteConfig>,
> {
  /** Base URL for all API requests */
  baseUrl: string;
  /** Generated route metadata mapping operationId -> route info */
  routes: TRoutes;
  /** Default headers to include with every request */
  headers?: Record<string, string>;
  /** Custom fetch implementation (defaults to global fetch) */
  fetch?: typeof fetch;
  /** Auth token propagation from previous step responses */
  auth?: {
    /** Step name to extract token from */
    fromStep: string;
    /** Path to token in response (e.g., "accessToken" or "data.token") */
    tokenPath: string;
    /** Header name (defaults to "Authorization") */
    headerName?: string;
    /** Header prefix (defaults to "Bearer ") */
    headerPrefix?: string;
  };
}

// =============================================================================
// HTTP Error
// =============================================================================

export class HttpError extends Error {
  constructor(
    public status: number,
    public statusText: string,
    public body: string,
  ) {
    super(`HTTP ${status}: ${statusText}`);
    this.name = "HttpError";
  }
}

// =============================================================================
// HTTP Executor
// =============================================================================

/**
 * Create an HTTP executor for a protocol.
 *
 * Maps protocol steps to HTTP endpoints using operationId to look up
 * route information from generated metadata.
 *
 * @example
 * ```typescript
 * import { apiRoutes } from "./api-routes.ts"; // Generated by tsgen
 *
 * const executor = createHttpExecutor(authProtocol, {
 *   baseUrl: "https://api.example.com",
 *   routes: apiRoutes,
 *   auth: {
 *     fromStep: "login",
 *     tokenPath: "accessToken",
 *   },
 * });
 *
 * const session = createSession(authProtocol, executor);
 * const { response } = await session.execute("login", { username: "alice", password: "secret" });
 * ```
 */
export function createHttpExecutor<
  TSteps extends Record<string, AnyStep>,
  TRoutes extends Record<string, RouteConfig>,
>(
  protocol: Protocol<string, TSteps>,
  config: HttpExecutorConfig<TRoutes>,
): StepExecutor {
  const fetchFn = config.fetch ?? fetch;

  return {
    async execute(
      stepName: string,
      request: unknown,
      ctx: ExecutionContext,
    ): Promise<unknown> {
      const step = protocol.steps[stepName];

      if (!step) {
        throw new Error(`Unknown step: ${stepName}`);
      }

      // Get route by operationId, fall back to step name
      const routeId = step.operationId ?? stepName;
      const route = config.routes[routeId as keyof TRoutes];

      if (!route) {
        throw new Error(
          `No route found for step "${stepName}" (operationId: ${routeId})`,
        );
      }

      const { method, path } = route;
      const resolvedPath = resolvePath(
        path,
        request as Record<string, unknown>,
      );
      const url = config.baseUrl + resolvedPath;

      // Build headers
      const headers: Record<string, string> = {
        "Content-Type": "application/json",
        ...config.headers,
      };

      // Auto-inject auth token from previous step response
      if (config.auth) {
        const prevResponse = ctx.responses[config.auth.fromStep];
        if (prevResponse !== undefined) {
          const token = getPath(prevResponse, config.auth.tokenPath);
          if (token !== undefined && token !== null) {
            const headerName = config.auth.headerName ?? "Authorization";
            const prefix = config.auth.headerPrefix ?? "Bearer ";
            headers[headerName] = prefix + String(token);
          }
        }
      }

      // Build request options
      const requestInit: RequestInit = {
        method,
        headers,
      };

      // Add body for non-GET methods
      if (method !== "GET" && method !== "HEAD") {
        requestInit.body = JSON.stringify(request);
      }

      // Execute request
      const response = await fetchFn(url, requestInit);

      if (!response.ok) {
        const body = await response.text();
        throw new HttpError(response.status, response.statusText, body);
      }

      // Parse response
      const contentType = response.headers.get("content-type") ?? "";
      if (contentType.includes("application/json")) {
        return response.json();
      }

      // Return empty object for no-content responses
      if (response.status === 204) {
        return {};
      }

      // Return text for non-JSON responses
      return { text: await response.text() };
    },
  };
}

// =============================================================================
// Helpers
// =============================================================================

/**
 * Resolve path parameters from request object.
 *
 * Replaces {param} placeholders in the path with values from the request.
 *
 * @example
 * resolvePath("/users/{userId}/posts/{postId}", { userId: "123", postId: "456" })
 * // Returns: "/users/123/posts/456"
 */
function resolvePath(path: string, request: Record<string, unknown>): string {
  return path.replace(/\{(\w+)\}/g, (_, key) => {
    if (key in request && request[key] !== undefined) {
      return encodeURIComponent(String(request[key]));
    }
    return `{${key}}`;
  });
}

/**
 * Get a nested value from an object by path.
 *
 * @example
 * getPath({ data: { token: "abc" } }, "data.token") // Returns: "abc"
 */
function getPath(obj: unknown, path: string): unknown {
  return path.split(".").reduce<unknown>(
    (current, key) => {
      if (current !== null && typeof current === "object") {
        return (current as Record<string, unknown>)[key];
      }
      return undefined;
    },
    obj,
  );
}
